/*
2026 NVIDIA CORPORATION & AFFILIATES
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package udev

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	execUtils "k8s.io/utils/exec"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/Mellanox/nic-configuration-operator/api/v1alpha1"
	"github.com/Mellanox/nic-configuration-operator/pkg/consts"
	"github.com/Mellanox/nic-configuration-operator/pkg/utils"
)

const (
	// UdevNetRulesFile is the path to the udev rules file for network interface naming
	UdevNetRulesFile = "/etc/udev/rules.d/70-nic-net-interface-naming.rules"
	// UdevRdmaRulesFile is the path to the udev rules file for RDMA interface naming
	UdevRdmaRulesFile = "/etc/udev/rules.d/60-nic-rdma-interface-naming.rules"

	// Placeholder tokens in the prefix templates
	NicIDPlaceholder   = "%nic_id%"
	PlaneIDPlaceholder = "%plane_id%"
	RailIDPlaceholder  = "%rail_id%"

	// UdevRulesHeader is the header comment for the generated udev rules file
	UdevRulesHeader = "# Auto-generated by nic-configuration-operator\n# Do not edit manually\n\n"
)

// ExpectedInterfaceNames holds the expected net and rdma device names for a PCI address
type ExpectedInterfaceNames struct {
	NetDevice  string
	RdmaDevice string
}

// UdevManager handles udev rules generation and application for NIC interface naming
type UdevManager interface {
	// ApplyUdevRules generates udev rules from devices with InterfaceNameTemplate specs
	// and writes them to the udev rules files.
	// Returns:
	// - map[pciAddr]ExpectedInterfaceNames: expected interface names for each PCI address
	// - bool: true if rules were updated, false if no change
	// - error: any error that occurred
	ApplyUdevRules(ctx context.Context, devices []*v1alpha1.NicDevice) (map[string]ExpectedInterfaceNames, bool, error)
}

type udevManager struct {
	hostPath      string
	execInterface execUtils.Interface
}

// NewUdevManager creates a new UdevManager instance
func NewUdevManager() UdevManager {
	return &udevManager{
		hostPath:      consts.HostPath,
		execInterface: execUtils.New(),
	}
}

// ApplyUdevRules generates udev rules from devices with InterfaceNameTemplate specs
// and writes them to separate udev rules files for net and RDMA devices.
// If rules were updated, it reloads the udev rules and triggers the subsystems.
// Returns:
// - map[pciAddr]ExpectedInterfaceNames: expected interface names for each PCI address
// - bool: true if any rules were updated, false if no change
// - error: any error that occurred
func (m *udevManager) ApplyUdevRules(ctx context.Context, devices []*v1alpha1.NicDevice) (map[string]ExpectedInterfaceNames, bool, error) {
	log.Log.V(2).Info("UdevManager.ApplyUdevRules", "deviceCount", len(devices))

	// Generate rules content for net and RDMA devices separately, and collect expected names
	netRulesContent, rdmaRulesContent, expectedNames := m.generateUdevRules(devices)

	// Write net rules file
	netUpdated, err := m.writeRulesFile(UdevNetRulesFile, netRulesContent)
	if err != nil {
		return nil, false, err
	}

	// Write RDMA rules file
	rdmaUpdated, err := m.writeRulesFile(UdevRdmaRulesFile, rdmaRulesContent)
	if err != nil {
		return nil, false, err
	}

	// If any rules were updated, reload udev rules and trigger the subsystems
	if netUpdated || rdmaUpdated {
		if err := m.reloadUdevRules(ctx); err != nil {
			return nil, false, err
		}
	}

	return expectedNames, netUpdated || rdmaUpdated, nil
}

// reloadUdevRules reloads udev rules and triggers the net and infiniband subsystems.
// Commands are executed via chroot command to the host filesystem to work correctly from within a container.
// Using chroot command instead of syscall.Chroot to avoid race conditions with concurrent goroutines.
func (m *udevManager) reloadUdevRules(ctx context.Context) error {
	log.Log.Info("Reloading udev rules")

	// Reload udev rules (via chroot to host)
	cmd := m.execInterface.CommandContext(ctx, "chroot", m.hostPath, "udevadm", "control", "--reload-rules")
	if _, err := utils.RunCommand(cmd); err != nil {
		log.Log.Error(err, "Failed to reload udev rules")
		return fmt.Errorf("failed to reload udev rules: %w", err)
	}

	// Trigger infiniband subsystem
	cmd = m.execInterface.CommandContext(ctx, "chroot", m.hostPath, "udevadm", "trigger", "--action=add", "--subsystem-match=infiniband")
	if _, err := utils.RunCommand(cmd); err != nil {
		log.Log.Error(err, "Failed to trigger infiniband subsystem")
		return fmt.Errorf("failed to trigger infiniband subsystem: %w", err)
	}

	// Trigger net subsystem
	cmd = m.execInterface.CommandContext(ctx, "chroot", m.hostPath, "udevadm", "trigger", "--action=add", "--subsystem-match=net")
	if _, err := utils.RunCommand(cmd); err != nil {
		log.Log.Error(err, "Failed to trigger net subsystem")
		return fmt.Errorf("failed to trigger net subsystem: %w", err)
	}

	// Wait for udev event queue to be processed
	cmd = m.execInterface.CommandContext(ctx, "chroot", m.hostPath, "udevadm", "settle")
	if _, err := utils.RunCommand(cmd); err != nil {
		log.Log.Error(err, "Failed to wait for udev events to settle")
		return fmt.Errorf("failed to wait for udev events to settle: %w", err)
	}

	log.Log.Info("Udev rules reloaded and subsystems triggered")
	return nil
}

// writeRulesFile writes the rules content to a file if it has changed.
// Returns true if the file was updated, false if no change.
func (m *udevManager) writeRulesFile(rulesFile, content string) (bool, error) {
	rulesFilePath := filepath.Join(m.hostPath, rulesFile)

	// Check if the file already exists with the same content
	existingContent, err := os.ReadFile(rulesFilePath)
	if err == nil {
		if bytes.Equal(existingContent, []byte(content)) {
			log.Log.V(2).Info("Udev rules file already up to date, skipping write", "path", rulesFilePath)
			return false, nil
		}
		// Debug: log why content differs
		log.Log.Info("Udev rules file content differs",
			"path", rulesFilePath,
			"existingLen", len(existingContent),
			"newLen", len(content),
			"existingContent", string(existingContent),
			"newContent", content)
	} else {
		log.Log.Info("Udev rules file does not exist or cannot be read", "path", rulesFilePath, "error", err)
	}

	// Ensure the directory exists
	rulesDir := filepath.Dir(rulesFilePath)
	if err := os.MkdirAll(rulesDir, 0755); err != nil {
		log.Log.Error(err, "Failed to create udev rules directory", "path", rulesDir)
		return false, fmt.Errorf("failed to create udev rules directory: %w", err)
	}

	// Write the rules file
	if err := os.WriteFile(rulesFilePath, []byte(content), 0644); err != nil {
		log.Log.Error(err, "Failed to write udev rules file", "path", rulesFilePath)
		return false, fmt.Errorf("failed to write udev rules file: %w", err)
	}

	log.Log.Info("Udev rules file updated", "path", rulesFilePath)
	return true, nil
}

// generateUdevRules creates udev rules content for all devices, returning separate content for net and RDMA rules,
// along with a map of PCI addresses to expected interface names.
// Rules are sorted by PCI address to ensure deterministic output.
func (m *udevManager) generateUdevRules(devices []*v1alpha1.NicDevice) (netRules, rdmaRules string, expectedNames map[string]ExpectedInterfaceNames) {
	// Collect rules keyed by PCI address for sorting
	netRulesMap := make(map[string]string)
	rdmaRulesMap := make(map[string]string)
	expectedNames = make(map[string]ExpectedInterfaceNames)

	for _, device := range devices {
		if device.Spec.InterfaceNameTemplate == nil {
			continue
		}

		spec := device.Spec.InterfaceNameTemplate

		// Generate rules for each port of the device
		for portIndex, port := range device.Status.Ports {
			if port.PCI == "" {
				continue
			}

			// Get the plane index for this port (if available)
			planeIndex := 0
			if portIndex < len(spec.PlaneIndices) {
				planeIndex = spec.PlaneIndices[portIndex]
			}

			// Generate net device rule
			netDeviceName := substituteTemplatePlaceholders(
				spec.NetDevicePrefix,
				spec.NicIndex,
				planeIndex,
				spec.RailIndex,
			)
			if netDeviceName != "" {
				netRulesMap[port.PCI] = generateNetDeviceRule(port.PCI, netDeviceName)
			}

			// Generate rdma device rule
			rdmaDeviceName := substituteTemplatePlaceholders(
				spec.RdmaDevicePrefix,
				spec.NicIndex,
				planeIndex,
				spec.RailIndex,
			)
			if rdmaDeviceName != "" {
				rdmaRulesMap[port.PCI] = generateRdmaDeviceRule(port.PCI, rdmaDeviceName)
			}

			// Store expected names for this PCI address
			expectedNames[port.PCI] = ExpectedInterfaceNames{
				NetDevice:  netDeviceName,
				RdmaDevice: rdmaDeviceName,
			}
		}
	}

	// Sort PCI addresses for deterministic output
	pciAddresses := make([]string, 0, len(expectedNames))
	for pci := range expectedNames {
		pciAddresses = append(pciAddresses, pci)
	}
	sort.Strings(pciAddresses)

	// Build sorted rules content
	var netBuilder, rdmaBuilder strings.Builder
	netBuilder.WriteString(UdevRulesHeader)
	rdmaBuilder.WriteString(UdevRulesHeader)

	for _, pci := range pciAddresses {
		if rule, ok := netRulesMap[pci]; ok {
			netBuilder.WriteString(rule)
			netBuilder.WriteString("\n")
		}
		if rule, ok := rdmaRulesMap[pci]; ok {
			rdmaBuilder.WriteString(rule)
			rdmaBuilder.WriteString("\n")
		}
	}

	return netBuilder.String(), rdmaBuilder.String(), expectedNames
}

// substituteTemplatePlaceholders replaces placeholder tokens with actual values
func substituteTemplatePlaceholders(template string, nicIndex, planeIndex, railIndex int) string {
	if template == "" {
		return ""
	}

	result := template
	result = strings.ReplaceAll(result, NicIDPlaceholder, strconv.Itoa(nicIndex))
	result = strings.ReplaceAll(result, PlaneIDPlaceholder, strconv.Itoa(planeIndex))
	result = strings.ReplaceAll(result, RailIDPlaceholder, strconv.Itoa(railIndex))

	return result
}

// generateNetDeviceRule creates a udev rule for a network device
func generateNetDeviceRule(pciAddress, deviceName string) string {
	// Format: SUBSYSTEM=="net", ACTION=="add", KERNELS=="<pci>", NAME="<name>"
	return fmt.Sprintf(`SUBSYSTEM=="net", ACTION=="add", KERNELS=="%s", NAME="%s"`, pciAddress, deviceName)
}

// generateRdmaDeviceRule creates a udev rule for an RDMA device
func generateRdmaDeviceRule(pciAddress, deviceName string) string {
	// Format: ACTION=="add", KERNELS=="<pci>", SUBSYSTEM=="infiniband", RUN+="/usr/bin/rdma dev set %k name <name>"
	// Using RUN+= instead of PROGRAM= because we just want to execute the command, not capture its output
	return fmt.Sprintf(`ACTION=="add", KERNELS=="%s", SUBSYSTEM=="infiniband", RUN+="/usr/bin/rdma dev set %%k name %s"`, pciAddress, deviceName)
}
